using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Sharp86;

namespace Sharp86UnitTests
{
    public class CPUUnitTests : CPU, IMemoryBus, IPortBus
    {
        public CPUUnitTests()
        {
            MemoryBus = this;
            PortBus = this;
        }

        byte[] _mem;
        ushort _emitLocation;
        StringBuilder _emitBuffer = new StringBuilder();

        [TestInitialize]
        public override void Reset()
        {
            base.Reset();

            _emitLocation = 0x100;
            _emitBuffer.Length = 0;
            _emitBuffer.Append("ORG 0x100\n");
            ip = 0x100;
            _mem = new byte[0x20000];
            _portReadQueues = new Dictionary<ushort, List<byte>>();
            _portWrittenQueues = new Dictionary<ushort, List<byte>>();
            _accessedPorts = new HashSet<ushort>();
        }

        public bool IsExecutableSelector(ushort seg)
        {
            return true;
        }

        public byte ReadByte(ushort seg, ushort offset)
        {
            var addr = (seg << 4) + offset;
            var b = _mem[addr];
            return b;
        }

        public void WriteByte(ushort seg, ushort offset, byte value)
        {
            var addr = (seg << 4) + offset;
            _mem[addr] = value;
        }

        protected void emit(string asm)
        {
            _emitBuffer.Append(asm);
            _emitBuffer.Append("\n");
        }

        void flushEmit()
        {
            if (_emitBuffer.Length == 0)
                return;

            // write the text
            System.IO.File.WriteAllText("temp.asm", _emitBuffer.ToString(), Encoding.ASCII);

            // Execute the assembler
            var processStartInfo = new ProcessStartInfo
            {
                FileName = @"C:\users\brad\dropbox\wintools\yasm.exe",
                Arguments = "temp.asm -o temp.bin -l temp.lst",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                RedirectStandardInput = true,
                CreateNoWindow = true,
                UseShellExecute = false,
                WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden
            };
            var process = Process.Start(processStartInfo);
            //var output = process.StandardError.ReadToEnd();
            process.WaitForExit();
            if (process.ExitCode != 0)
                throw new InvalidOperationException(string.Format("YASM failed"));


            /*
            0 -> 0
            1 -> 3
            2 -> 2
            3 -> 1
            */

            // Read the generated bytes
            var bytes = System.IO.File.ReadAllBytes("temp.bin");
            for (int i=(4-(_emitLocation % 4))%4; i<bytes.Length; i++)
            {
                WriteByte(0, _emitLocation++, bytes[i]);
            }

            // Clear the emit buffer
            _emitBuffer.Length = 0;
            _emitBuffer.AppendFormat("ORG {0:X}H\n", _emitLocation);
        }

        protected void run()
        {
            flushEmit();
            while (ip != _emitLocation)
            {
                Run(1);
            }
        }
        protected void step()
        {
            flushEmit();
            Run(1);
        }

        Dictionary<ushort, List<byte>> _portReadQueues;
        Dictionary<ushort, List<byte>> _portWrittenQueues;
        HashSet<ushort> _accessedPorts;

        public bool WasPortAccessed(ushort port)
        {
            return _accessedPorts.Contains(port);
        }

        public void EnqueueReadPortByte(ushort port, byte value)
        {
            List<byte> queue;
            if (!_portReadQueues.TryGetValue(port, out queue))
            {
                queue = new List<byte>();
                _portReadQueues.Add(port, queue);
            }

            queue.Add(value);
        }

        public byte DequeueWrittenPortByte(ushort port)
        {
            List<byte> queue;
            if (!_portWrittenQueues.TryGetValue(port, out queue))
                return 0;

            if (queue.Count == 0)
                return 0;

            var data = queue[0];
            queue.RemoveAt(0);
            return data;
        }

        public virtual byte ReadPortByte(ushort port)
        {
            _accessedPorts.Add(port);

            List<byte> queue;
            if (!_portReadQueues.TryGetValue(port, out queue))
                return 0;

            if (queue.Count == 0)
                return 0;

            var data = queue[0];
            queue.RemoveAt(0);
            return data;
        }

        public virtual void WritePortByte(ushort port, byte value)
        {
            _accessedPorts.Add(port);

            List<byte> queue;
            if (!_portWrittenQueues.TryGetValue(port, out queue))
            {
                queue = new List<byte>();
                _portWrittenQueues.Add(port, queue);
            }

            queue.Add(value);
        }

        public ushort ReadWord(ushort seg, ushort offset)
        {
            return (ushort)(ReadByte(seg, offset) | ReadByte(seg, (ushort)(offset + 1)) << 8);
        }

        public void WriteWord(ushort seg, ushort offset, ushort value)
        {
            WriteByte(seg, offset, (byte)(value & 0xFF));
            WriteByte(seg, (ushort)(offset + 1), (byte)(value >> 8));
        }

    }
}
